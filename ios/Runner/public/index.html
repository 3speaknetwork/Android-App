<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="3Speak Acela" />
    <title>3Speak Acela</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <!-- <script src="./hive.min.js"></script> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.1.0/uuidv4.min.js"></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"
      integrity="sha512-E8QSvWZ0eCLGk4km3hxSsNmGWbLtSCSUcewDQPQWZF6pEU8GlT8a5fF32wOl1i8ftdMhssTrF/OhyGWwonTcXA=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <script src="https://cdn.jsdelivr.net/npm/@hiveio/hive-js/dist/hive.min.js"></script>
    <script>
      function validateHiveKey(accountName, postingKey) {
        console.log("In here before async");
        hive.api
          .getAccountsAsync([accountName])
          .then(function (accounts) {
            console.log("In here after async");
            console.log("Accounts: ", accounts);
            const pubWif = accounts[0].posting.key_auths[0][0];
            console.log("PubWif: ", pubWif);
            const Valid = hive.auth.wifIsValid(postingKey, pubWif);
            console.log(`is valid ${Valid}`);
            var result = {
              type: "validateHiveKey",
              valid: Valid,
              accountName: accountName,
              error: "",
            };
            window.webkit.messageHandlers.acela.postMessage(result);
            // Android.postMessage(JSON.stringify(result));
          })
          .catch(function (err) {
            console.log("Error: ", err);
            var result = {
              type: "validateHiveKey",
              valid: false,
              accountName: accountName,
              error: err.message,
            };
            window.webkit.messageHandlers.acela.postMessage(result);
            // Android.postMessage(JSON.stringify(result));
          });
      }

      function decryptMemo(accountName, postingKey, encrypted) {
        console.log("In here before async");
        hive.api
          .getAccountsAsync([accountName])
          .then(function (accounts) {
            console.log("In here after async");
            console.log("Accounts: ", accounts);
            const pubWif = accounts[0].posting.key_auths[0][0];
            console.log("PubWif: ", pubWif);
            const Valid = hive.auth.wifIsValid(postingKey, pubWif);
            console.log(`is valid ${Valid}`);
            let decrypted = hive.memo.decode(postingKey, encrypted);
            let result = {
              type: "decryptedMemo",
              accountName: accountName,
              decrypted: decrypted,
              error: "",
            };
            window.webkit.messageHandlers.acela.postMessage(result);
            // Android.postMessage(JSON.stringify(result));
          })
          .catch(function (err) {
            console.log("Error: ", err);
            let result = {
              type: "decryptedMemo",
              accountName: accountName,
              decrypted: "",
              error: err.message,
            };
            window.webkit.messageHandlers.acela.postMessage(result);
            // Android.postMessage(JSON.stringify(result));
          });
      }

      function processTags(tags) {
        const fallback = ["threespeak", "video"];
        const processed = [];
        for (let tag of tags) {
          tag = tag.toLowerCase().trim();
          if (!tag.startsWith("hive-") && tag.length >= 3) {
            tag = tag.replace(/[^a-z0-9]/g, "");
            if (!processed.includes(tag) && tag.length >= 3) {
              processed.push(tag);
            }
          }
        }
        return processed.length === 0 ? fallback : processed;
      }

      function customStringEscaping(string) {
        return string.split("'").join("’").split('"').join("“");
      }

      function buildJSONMetadata(
        thumbnail,
        videoV2,
        description,
        title,
        tags,
        author,
        permlink,
        duration,
        size,
        file,
        language,
        firstUpload,
        cdn
      ) {
        // 2. set the sourceMap
        const sourceMap = [];
        if (videoV2 !== undefined) {
          sourceMap.push({
            type: "video",
            url: videoV2,
            format: "m3u8",
          });
        }
        let escapedVideoDescription = customStringEscaping(description);
        let escapedVideoTitle = customStringEscaping(title);
        return {
          tags: processTags(tags.split(",")),
          app: "3speakMobileiOS/1.0.4-48",
          type: "3speak/video",
          image: [thumbnail],
          video: {
            info: {
              platform: "3speak",
              title: escapedVideoTitle,
              author: author,
              permlink: permlink,
              duration: duration,
              filesize: size,
              file: file,
              lang: language,
              firstUpload: firstUpload,
              video_v2: videoV2,
              sourceMap: [
                ...sourceMap,
                {
                  type: "thumbnail",
                  url: thumbnail,
                },
              ],
            },
            content: {
              description: escapedVideoDescription,
              tags: processTags(tags.split(",")),
            },
          },
        };
      }

      function renderTemplate(baseThumbUrl, owner, permlink, description) {
        const PostTemplate = `<br/><br/>[![](@@@thumbnail@@@)](https://3speak.tv/watch?v=@@@author@@@/@@@permlink@@@)<br/><br/>[Watch on 3Speak](https://3speak.tv/watch?v=@@@author@@@/@@@permlink@@@)<br/><br/><br/><br/>---<br/><br/>@@@description@@@<br/><br/>---<br/><br/>[3Speak](https://3speak.tv/watch?v=@@@author@@@/@@@permlink@@@)<br/><br/>[Posted from 3Speak iOS App](https://testflight.apple.com/join/0tipqwsZ) for [3Speak](https://hive.blog/@spknetwork)<br/>[Developed and maintained by](https://hivesigner.com/sign/account-witness-vote?witness=sagarkothari88&approve=1) @sagarkothari88`;
        return PostTemplate.replace(/@@@thumbnail@@@/g, baseThumbUrl)
          .replace(/@@@author@@@/g, owner)
          .replace(/@@@permlink@@@/g, permlink)
          .replace(/@@@description@@@/g, description);
      }

      function videoObjectForBody(description, thumbnail, owner, permlink) {
        let escapedVideoDescription = customStringEscaping(description);
        return {
          baseThumbUrl: thumbnail,
          owner: owner,
          permlink: permlink,
          description: escapedVideoDescription,
        };
      }

      function buildPublishCustomJson(
        owner,
        permlink,
        language,
        duration,
        title
      ) {
        return [
          "custom_json",
          {
            required_posting_auths: [owner],
            required_auths: [],
            id: "3speak-publish",
            json: JSON.stringify({
              author: owner,
              permlink: permlink,
              category: "general",
              language: language,
              duration: duration,
              title: title,
            }),
          },
        ];
      }

      function newPostVideo(
        thumbnail,
        videoV2,
        dDescription,
        dTitle,
        tags,
        author,
        permlink,
        duration,
        size,
        file,
        language,
        firstUpload,
        benes,
        beneWeights,
        postingKey,
        community,
        ipfsHash,
        hasKey,
        hasAuthKey
      ) {
        let description = atob(dDescription);
        description = decodeURIComponent(escape(description));
        description = `${description}\nIPFS HASH: ${ipfsHash}`;
        let title = atob(dTitle);
        title = decodeURIComponent(escape(title));
        let jsonMetaData = buildJSONMetadata(
          thumbnail,
          videoV2,
          description,
          title,
          tags,
          author,
          permlink,
          duration,
          size,
          file,
          language,
          firstUpload
        );
        let customJson = buildPublishCustomJson(
          author,
          permlink,
          language,
          duration,
          title
        );
        let newBen = [
          { account: "threespeakleader", weight: 100 },
          { account: "spk.beneficiary", weight: 850 },
        ];
        hive.api
          .getAccountsAsync([author])
          .then(function (accounts) {
            const account = accounts[0];
            if (account && account.json_metadata) {
              let json = JSON.parse(account.json_metadata);
              if (json.beneficiaries) {
                if (Array.isArray(json.beneficiaries)) {
                  let benefactors = json.beneficiaries
                    .filter((x) => x.name !== "spk.delegation")
                    .filter((x) => x.name && x.label);
                  for (let bene of benefactors) {
                    switch (bene.label) {
                      case "referrer":
                        newBen.push({
                          account: bene.name,
                          weight: bene.weight,
                        });
                        break;
                      case "provider":
                        newBen.push({
                          account: bene.name,
                          weight: bene.weight,
                        });
                        break;
                      case "creator":
                        newBen.push({
                          account: bene.name,
                          weight: bene.weight,
                        });
                        break;
                    }
                  }
                }
              }
            }
            benes.split(",").forEach((string, index) => {
              const value = parseInt(beneWeights.split(",")[index]);
              newBen.push({ account: string, weight: value });
            });
            newBen.sort((a, b) => {
              let fa = a.account.toLowerCase(),
                fb = b.account.toLowerCase();
              if (fa < fb) return -1;
              if (fa > fb) return 1;
              return 0;
            });
            let benefactor_global = [[0, { beneficiaries: newBen }]];
            let comment_options = [
              "comment_options",
              {
                author: author,
                permlink: permlink,
                allow_votes: true,
                max_accepted_payout: "100000.000 SBD",
                percent_hbd: 10000,
                allow_curation_rewards: true,
                extensions: benefactor_global,
              },
            ];
            let videoObject = videoObjectForBody(
              description,
              thumbnail,
              author,
              permlink
            );
            let body = renderTemplate(
              videoObject.baseThumbUrl,
              videoObject.owner,
              videoObject.permlink,
              videoObject.description
            );
            hive.broadcast.updateOperations();
            const operations = [];
            operations.push([
              "comment",
              {
                parent_author: "",
                parent_permlink: community,
                author: author,
                permlink: permlink,
                title: title.substr(0, 254),
                body: body,
                json_metadata: JSON.stringify(jsonMetaData),
              },
            ]);
            operations.push(comment_options);
            operations.push(customJson);
            console.log(`operations are ${JSON.stringify(operations)}`);
            if (
              hasKey !== null &&
              hasAuthKey !== null &&
              hasKey.length > 0 &&
              hasAuthKey.length > 0
            ) {
              const sign_data = {
                key_type: "posting",
                ops: operations,
                broadcast: true,
              };
              const data = CryptoJS.AES.encrypt(
                JSON.stringify(sign_data),
                hasAuthKey
              ).toString();
              const payload = {
                cmd: "sign_req",
                account: author,
                token: hasKey,
                data: data,
              };
              ws.send(JSON.stringify(payload));
            } else {
              tryPublish(operations, postingKey)
                .then((result) => {
                  var newResult = {
                    type: "postVideo",
                    valid: true,
                    error: "success",
                  };
                  window.webkit.messageHandlers.acela.postMessage(newResult);
                  //Android.postMessage(JSON.stringify(newResult));
                })
                .catch((error) => {
                  console.error(error);
                  var result = {
                    type: "postVideo",
                    valid: false,
                    error: error.message,
                  };
                  window.webkit.messageHandlers.acela.postMessage(result);
                  //Android.postMessage(JSON.stringify(result));
                });
            }
          })
          .catch(function (err) {
            console.error(err);
            var result = {
              type: "postVideo",
              valid: false,
              error: err.message,
            };
            window.webkit.messageHandlers.acela.postMessage(result);
            //Android.postMessage(JSON.stringify(result));
          });
      }
    </script>

    <script>
      // HAS variables
      const HAS_SERVER = "wss://hive-auth.arcange.eu";
      const HAS_APP_DATA = {
        name: "3Speak Mobile iOS App",
        description: "3Speak Mobile iOS App with HAS Integration",
      };
      const app_key = uuidv4();
      let username;
      let token;
      let expire;
      let auth_key;
      let auth_uuid;
      // Initialize WebSocket
      let ws = undefined;
      if ("WebSocket" in window) {
        // The browser support Websocket
        ws = new WebSocket(HAS_SERVER);
        console.log(`Starting WebSocket with ${HAS_SERVER}`);
        ws.onopen = function () {
          // Web Socket is connected
          console.log("WebSocket connected");
        };
        ws.onmessage = function (event) {
          console.log(`event - ${JSON.parse(event.data)}`);
          //const msg = JSON.parse(evt.data)
          console.log(event.data);
          const message =
            typeof event.data == "string" ? JSON.parse(event.data) : event.data;
          // Process HAS <-> PKSA protocol
          if (message.cmd) {
            switch (message.cmd) {
              case "auth_wait":
                // Update QRCode
                const json = JSON.stringify({
                  account: username,
                  uuid: message.uuid,
                  key: auth_key,
                  host: HAS_SERVER,
                });
                const URI = `has://auth_req/${btoa(json)}`;
                console.log("done");
                console.log(`has auth is - ${URI}`);
                replyToNative({
                  type: "getRedirectUri",
                  valid: true,
                  username: username,
                  error: "",
                  data: URI,
                });
                break;
              case "auth_ack":
                try {
                  // Try to decrypt and parse payload data
                  message.data = JSON.parse(
                    CryptoJS.AES.decrypt(message.data, auth_key).toString(
                      CryptoJS.enc.Utf8
                    )
                  );
                  token = message.data.token;
                  expire = message.data.expire;
                } catch (e) {
                  // Decryption failed - ignore message
                  console.error("decryption failed", e.message);
                  click_logout();
                }
                break;
              case "auth_nack":
                click_logout();
                break;
              case "sign_wait":
                alert(`transaction ${message.uuid} is waiting for approval`);
                replyToNative({
                  type: "postVideo",
                  valid: true,
                  error: `Transaction ${message.uuid} is waiting for approval. Open HiveKeychain app, approve, come back here & hit Save button again.`,
                });
                break;
              case "sign_ack":
                console.log(`transaction ${message.uuid} approved`);
                replyToNative({
                  type: "postVideo",
                  valid: true,
                  error: "success",
                });
                break;
              case "sign_nack":
                alert(`transaction ${message.uuid} has been declined`);
                break;
              case "sign_err":
                alert(`transaction ${message.uuid} failed: ${message.error}`);
                break;
            }
          }
        };
        // websocket is closed.
        ws.onclose = function () {
          console.log("WebSocket closed. Please reload the page...");
        };
        ws.onerror = function (e) {
          console.log(`WebSocket error. ${e}\nPlease reload the page...`);
        };
      } else {
        console.log("The browser doesn't support WebSocket");
      }

      function getUserInfo() {
        replyToNative({
          type: "hiveAuthUserInfo",
          valid: true,
          username: username,
          error: "",
          data: `${token},${expire},${auth_key}`,
        });
      }

      function getRedirectUri(uname) {
        username = uname.toLowerCase();
        const auth_data = {
          app: HAS_APP_DATA,
          token: undefined,
          challenge: undefined,
        };

        auth_key = uuidv4();
        const data = CryptoJS.AES.encrypt(
          JSON.stringify(auth_data),
          auth_key
        ).toString();
        const payload = { cmd: "auth_req", account: username, data: data };
        ws.send(JSON.stringify(payload));
      }

      function getRedirectUriData(uname) {
        username = uname.toLowerCase();
        const auth_data = {
          app: HAS_APP_DATA,
          token: undefined,
          challenge: undefined,
        };
        auth_key = uuidv4();
        const data = CryptoJS.AES.encrypt(
          JSON.stringify(auth_data),
          auth_key
        ).toString();
        const payload = { data: data, authKey: auth_key };
        const payloadData = JSON.stringify(payload);
        replyToNative({
          type: "getRedirectUriData",
          valid: true,
          username: uname,
          error: "",
          data: payloadData,
        });
      }

      function click_logout() {
        username = undefined;
        token = undefined;
        expire = undefined;
      }

      function click_posting() {
        const op = [
          "custom_json",
          {
            id: "test",
            json: '{"action":"test HAS posting"}',
            required_auths: [],
            required_posting_auths: [username],
          },
        ];
        const sign_data = {
          key_type: "posting",
          ops: [op],
          broadcast: true,
        };
        const data = CryptoJS.AES.encrypt(
          JSON.stringify(sign_data),
          auth_key
        ).toString();
        const payload = {
          cmd: "sign_req",
          account: username,
          token: token,
          data: data,
        };
        ws.send(JSON.stringify(payload));
      }
      function click_active() {
        const op = [
          "transfer",
          {
            from: username,
            to: "arcange",
            amount: "0.001 HIVE",
            memo: "test HAS active",
          },
        ];
        const sign_data = {
          key_type: "active",
          ops: [op],
          broadcast: true,
        };
        const data = CryptoJS.AES.encrypt(
          JSON.stringify(sign_data),
          auth_key
        ).toString();
        const payload = {
          cmd: "sign_req",
          account: username,
          token: token,
          data: data,
        };
        ws.send(JSON.stringify(payload));
      }

      function replyToNative(result) {
        console.log(`Result is ${JSON.stringify(result)}`);
        window.webkit.messageHandlers.acela.postMessage(result);
        // Android.postMessage(JSON.stringify(result));
      }
    </script>
  </body>
</html>
