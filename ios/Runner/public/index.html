<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="3Speak Acela" />
    <title>3Speak Acela</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <!-- <script src="./hive.min.js"></script> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.1.0/uuidv4.min.js"></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"
      integrity="sha512-E8QSvWZ0eCLGk4km3hxSsNmGWbLtSCSUcewDQPQWZF6pEU8GlT8a5fF32wOl1i8ftdMhssTrF/OhyGWwonTcXA=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <script src="https://cdn.jsdelivr.net/npm/@hiveio/hive-js/dist/hive.min.js"></script>
    <script>
      const HAS_SERVER = "wss://hive-auth.arcange.eu";
      const HAS_APP_DATA = {
        name: "3Speak Mobile iOS App",
        description: "3Speak Mobile iOS App with HAS Integration",
      };
      const app_key = uuidv4();

      function validateHiveKey(accountName, postingKey) {
        console.log("In here before async");
        hive.api
          .getAccountsAsync([accountName])
          .then(function (accounts) {
            console.log("In here after async");
            console.log("Accounts: ", accounts);
            const pubWif = accounts[0].posting.key_auths[0][0];
            console.log("PubWif: ", pubWif);
            const Valid = hive.auth.wifIsValid(postingKey, pubWif);
            console.log(`is valid ${Valid}`);
            replyToNative({
              type: "validateHiveKey",
              valid: Valid,
              accountName: accountName,
              error: "",
            });
          })
          .catch(function (err) {
            console.log("Error: ", err);
            replyToNative({
              type: "validateHiveKey",
              valid: false,
              accountName: accountName,
              error: err.message,
            });
          });
      }

      function decryptMemo(accountName, postingKey, encrypted) {
        console.log("In here before async");
        hive.api
          .getAccountsAsync([accountName])
          .then(function (accounts) {
            console.log("In here after async");
            console.log("Accounts: ", accounts);
            const pubWif = accounts[0].posting.key_auths[0][0];
            console.log("PubWif: ", pubWif);
            const Valid = hive.auth.wifIsValid(postingKey, pubWif);
            console.log(`is valid ${Valid}`);
            let decrypted = hive.memo.decode(postingKey, encrypted);
            replyToNative({
              type: "decryptedMemo",
              accountName: accountName,
              decrypted: decrypted,
              error: "",
            });
          })
          .catch(function (err) {
            console.log("Error: ", err);
            replyToNative({
              type: "decryptedMemo",
              accountName: accountName,
              decrypted: "",
              error: err.message,
            });
          });
      }

      function processTags(tags) {
        const fallback = ["threespeak", "video"];
        const processed = [];
        for (let tag of tags) {
          tag = tag.toLowerCase().trim();
          if (!tag.startsWith("hive-") && tag.length >= 3) {
            tag = tag.replace(/[^a-z0-9]/g, "");
            if (!processed.includes(tag) && tag.length >= 3) {
              processed.push(tag);
            }
          }
        }
        return processed.length === 0 ? fallback : processed;
      }

      function customStringEscaping(string) {
        return string.split("'").join("’").split('"').join("“");
      }

      function buildJSONMetadata(
        thumbnail,
        videoV2,
        description,
        title,
        tags,
        author,
        permlink,
        duration,
        size,
        file,
        language,
        firstUpload,
        cdn
      ) {
        // 2. set the sourceMap
        const sourceMap = [];
        if (videoV2 !== undefined) {
          sourceMap.push({
            type: "video",
            url: videoV2,
            format: "m3u8",
          });
        }
        let escapedVideoDescription = customStringEscaping(description);
        let escapedVideoTitle = customStringEscaping(title);
        return {
          tags: processTags(tags.split(",")),
          app: "3speakMobileiOS/1.0.4-48",
          type: "3speak/video",
          image: [thumbnail],
          video: {
            info: {
              platform: "3speak",
              title: escapedVideoTitle,
              author: author,
              permlink: permlink,
              duration: duration,
              filesize: size,
              file: file,
              lang: language,
              firstUpload: firstUpload,
              video_v2: videoV2,
              sourceMap: [
                ...sourceMap,
                {
                  type: "thumbnail",
                  url: thumbnail,
                },
              ],
            },
            content: {
              description: escapedVideoDescription,
              tags: processTags(tags.split(",")),
            },
          },
        };
      }

      function renderTemplate(baseThumbUrl, owner, permlink, description) {
        const PostTemplate = `<br/><br/>[![](@@@thumbnail@@@)](https://3speak.tv/watch?v=@@@author@@@/@@@permlink@@@)<br/><br/>[Watch on 3Speak](https://3speak.tv/watch?v=@@@author@@@/@@@permlink@@@)<br/><br/><br/><br/>---<br/><br/>@@@description@@@<br/><br/>---<br/><br/>[3Speak](https://3speak.tv/watch?v=@@@author@@@/@@@permlink@@@)<br/><br/>[Posted from 3Speak iOS App](https://testflight.apple.com/join/0tipqwsZ) for [3Speak](https://hive.blog/@spknetwork)<br/>[Developed and maintained by](https://hivesigner.com/sign/account-witness-vote?witness=sagarkothari88&approve=1) @sagarkothari88`;
        return PostTemplate.replace(/@@@thumbnail@@@/g, baseThumbUrl)
          .replace(/@@@author@@@/g, owner)
          .replace(/@@@permlink@@@/g, permlink)
          .replace(/@@@description@@@/g, description);
      }

      function videoObjectForBody(description, thumbnail, owner, permlink) {
        let escapedVideoDescription = customStringEscaping(description);
        return {
          baseThumbUrl: thumbnail,
          owner: owner,
          permlink: permlink,
          description: escapedVideoDescription,
        };
      }

      function buildPublishCustomJson(
        owner,
        permlink,
        language,
        duration,
        title
      ) {
        return [
          "custom_json",
          {
            required_posting_auths: [owner],
            required_auths: [],
            id: "3speak-publish",
            json: JSON.stringify({
              author: owner,
              permlink: permlink,
              category: "general",
              language: language,
              duration: duration,
              title: title,
            }),
          },
        ];
      }

      function newPostVideo(
        thumbnail,
        videoV2,
        dDescription,
        dTitle,
        tags,
        author,
        permlink,
        duration,
        size,
        file,
        language,
        firstUpload,
        benes,
        beneWeights,
        postingKey,
        community,
        ipfsHash,
        hasKey,
        hasAuthKey
      ) {
        let description = atob(dDescription);
        description = decodeURIComponent(escape(description));
        description = `${description}\nIPFS HASH: ${ipfsHash}`;
        let title = atob(dTitle);
        title = decodeURIComponent(escape(title));
        let jsonMetaData = buildJSONMetadata(
          thumbnail,
          videoV2,
          description,
          title,
          tags,
          author,
          permlink,
          duration,
          size,
          file,
          language,
          firstUpload
        );
        let customJson = buildPublishCustomJson(
          author,
          permlink,
          language,
          duration,
          title
        );
        let newBen = [
          { account: "threespeakleader", weight: 100 },
          { account: "spk.beneficiary", weight: 850 },
        ];
        hive.api
          .getAccountsAsync([author])
          .then(function (accounts) {
            const account = accounts[0];
            if (account && account.json_metadata) {
              let json = JSON.parse(account.json_metadata);
              if (json.beneficiaries) {
                if (Array.isArray(json.beneficiaries)) {
                  let benefactors = json.beneficiaries
                    .filter((x) => x.name !== "spk.delegation")
                    .filter((x) => x.name && x.label);
                  for (let bene of benefactors) {
                    switch (bene.label) {
                      case "referrer":
                        newBen.push({
                          account: bene.name,
                          weight: bene.weight,
                        });
                        break;
                      case "provider":
                        newBen.push({
                          account: bene.name,
                          weight: bene.weight,
                        });
                        break;
                      case "creator":
                        newBen.push({
                          account: bene.name,
                          weight: bene.weight,
                        });
                        break;
                    }
                  }
                }
              }
            }
            benes.split(",").forEach((string, index) => {
              const value = parseInt(beneWeights.split(",")[index]);
              newBen.push({ account: string, weight: value });
            });
            newBen.sort((a, b) => {
              let fa = a.account.toLowerCase(),
                fb = b.account.toLowerCase();
              if (fa < fb) return -1;
              if (fa > fb) return 1;
              return 0;
            });
            let benefactor_global = [[0, { beneficiaries: newBen }]];
            let comment_options = [
              "comment_options",
              {
                author: author,
                permlink: permlink,
                allow_votes: true,
                max_accepted_payout: "100000.000 SBD",
                percent_hbd: 10000,
                allow_curation_rewards: true,
                extensions: benefactor_global,
              },
            ];
            let videoObject = videoObjectForBody(
              description,
              thumbnail,
              author,
              permlink
            );
            let body = renderTemplate(
              videoObject.baseThumbUrl,
              videoObject.owner,
              videoObject.permlink,
              videoObject.description
            );
            hive.broadcast.updateOperations();
            const operations = [];
            operations.push([
              "comment",
              {
                parent_author: "",
                parent_permlink: community,
                author: author,
                permlink: permlink,
                title: title.substr(0, 254),
                body: body,
                json_metadata: JSON.stringify(jsonMetaData),
              },
            ]);
            operations.push(comment_options);
            operations.push(customJson);
            console.log(`operations are ${JSON.stringify(operations)}`);
            if (
              hasKey !== undefined &&
              hasAuthKey !== undefined &&
              hasKey.length > 0 &&
              hasAuthKey.length > 0
            ) {
              const sign_data = {
                key_type: "posting",
                ops: operations,
                broadcast: true,
              };
              const data = CryptoJS.AES.encrypt(
                JSON.stringify(sign_data),
                hasAuthKey
              ).toString();
              replyToNative({
                type: "postVideo",
                valid: true,
                username: author,
                error: "",
                data: data,
              });
            } else {
              async function tryPublish(operations, key) {
                try {
                  return hive.broadcast.sendAsync(
                    { operations },
                    { posting: key }
                  );
                } catch (e) {
                  return e;
                }
              }
              tryPublish(operations, postingKey)
                .then((result) => {
                  replyToNative({
                    type: "postVideo",
                    valid: true,
                    username: author,
                  });
                })
                .catch((error) => {
                  console.error(error);
                  replyToNative({
                    type: "postVideo",
                    valid: false,
                    username: author,
                    error: error.message,
                  });
                });
            }
          })
          .catch(function (err) {
            console.error(err);
            replyToNative({
              type: "postVideo",
              valid: false,
              error: err.message,
            });
          });
      }

      function getRedirectUriData(uname) {
        username = uname.toLowerCase();
        const auth_data = {
          app: HAS_APP_DATA,
          token: undefined,
          challenge: undefined,
        };
        auth_key = uuidv4();
        const data = CryptoJS.AES.encrypt(
          JSON.stringify(auth_data),
          auth_key
        ).toString();
        const payload = { data: data, authKey: auth_key };
        const payloadData = JSON.stringify(payload);
        replyToNative({
          type: "getRedirectUriData",
          valid: true,
          username: uname,
          error: "",
          data: payloadData,
        });
      }

      function getPostingAuthOps(username, authKey) {
        hive.api.getAccounts([username], function (err, result) {
          console.log(err, result);
          if (
            (err === null || err === undefined) &&
            result != null &&
            result != undefined &&
            Array.isArray(result) &&
            result.length === 1
          ) {
            const account = result[0];
            let posting = account.posting;
            let doWeHavePostingAuth = false;
            if (Array.isArray(posting.account_auths)) {
              posting.account_auths.forEach(function (item) {
                if (item[0] === "threespeak") {
                  doWeHavePostingAuth = true;
                }
              });
              if (!doWeHavePostingAuth) {
                posting.account_auths.push(["threespeak", 1]);
                const newPostingAuth = {
                  weight_threshold: posting.weight_threshold,
                  account_auths: posting.account_auths,
                  key_auths: posting.key_auths,
                };
                const ops = [
                  [
                    "account_update2",
                    {
                      account: account,
                      posting: newPostingAuth,
                      extensions: [],
                    },
                  ],
                ];
                const sign_data = {
                  key_type: "active",
                  ops: operations,
                  broadcast: true,
                };
                const data = CryptoJS.AES.encrypt(
                  JSON.stringify(sign_data),
                  authKey
                ).toString();
                replyToNative({
                  type: "getPostingAuthOps",
                  valid: true,
                  username: username,
                  error: "",
                  data: data,
                });
              } else {
                replyToNative({
                  type: "getPostingAuthOps",
                  valid: true,
                  username: username,
                  error: "",
                  data: "",
                });
              }
            } else {
              replyToNative({
                type: "getPostingAuthOps",
                valid: false,
                username: username,
                error: "failed getting account information",
                data: "",
              });
            }
          } else {
            replyToNative({
              type: "getPostingAuthOps",
              valid: false,
              username: username,
              error: "failed getting account information",
              data: "",
            });
          }
        });
      }

      function getDecryptedChallenge(username, authKey, data) {
        try {
          // Try to decrypt and parse payload data
          const decryptedData = JSON.parse(
            CryptoJS.AES.decrypt(data, authKey).toString(CryptoJS.enc.Utf8)
          );
          const challenge = decryptedData.challenge;
          replyToNative({
            type: "getDecryptedChallenge",
            valid: true,
            username: username,
            error: "",
            data: challenge,
          });
        } catch (e) {
          replyToNative({
            type: "getDecryptedChallenge",
            valid: false,
            accountName: username,
            error: e.message,
          });
        }
      }

      function getDecryptedHASToken(username, authKey, data) {
        try {
          // Try to decrypt and parse payload data
          const decryptedData = JSON.parse(
            CryptoJS.AES.decrypt(data, authKey).toString(CryptoJS.enc.Utf8)
          );
          const token = decryptedData.token;
          const expire = decryptedData.expire;
          replyToNative({
            type: "getDecryptedHASToken",
            valid: true,
            username: username,
            error: "",
            data: `${token},${expire}`,
          });
        } catch (e) {
          replyToNative({
            type: "getDecryptedHASToken",
            valid: false,
            accountName: username,
            error: e.message,
          });
        }
      }

      function getEncryptedChallenge(username, authKey) {
        try {
          const challenge_data = {
            key_type: "posting",
            challenge: JSON.stringify({
              account: username,
              type: "hive_auth",
              client: "3speak_mobile_app",
              ts: Date.now(),
            }),
          };
          const data = CryptoJS.AES.encrypt(
            JSON.stringify(challenge_data),
            auth_key
          ).toString();
          replyToNative({
            type: "getEncryptedChallenge",
            valid: true,
            username: username,
            error: "",
            data: `${data}|${challenge_data.challenge}`,
          });
        } catch (e) {
          replyToNative({
            type: "getEncryptedChallenge",
            valid: false,
            accountName: username,
            error: e.message,
          });
        }
      }

      function replyToNative(result) {
        console.log(`Result is ${JSON.stringify(result)}`);
        window.webkit.messageHandlers.acela.postMessage(result);
        // Android.postMessage(JSON.stringify(result));
      }
    </script>
  </body>
</html>
